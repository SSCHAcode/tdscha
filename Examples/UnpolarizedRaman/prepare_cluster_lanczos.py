from __future__ import print_function

import cellconstructor as CC, cellconstructor.Phonons
import sscha, sscha.Ensemble

import tdscha, tdscha.DynamicalLanczos as DL
import time, numpy as np
import sys

geom = str(sys.argv[-1])

conv = {'x' : np.array([1,0,0]), 'y' : np.array([0,1,0]), 'z' : np.array([0,0,1])}

print(geom[-1])

# INPUT VARIABLES -------------------

# The dynamical matrix used to generate the ensemble
ORIGINAL_DYN = "dyn"
NQIRR = 1  # Number of irreducible q points of the dynamical matrix

# The final dynamical matrix (after the SSCHA minimization)
FINAL_DYN = "final_dyn"

# Temperature (in K) used to generate the ensemble
TEMPERATURE = 300
# Temperature for the Lanczos calculation (If None the same as TEMPERATURE)
FINAL_TEMPERATURE = None

# The ensemble data
ENSEMBLE_DIR = "data" # Directory of the ensemble
N_CONFIGS = 500 # Number of configurations
POPULATION_ID = 0 # Population of the ensemble
LOAD_BIN = True # If true, load a binary ensemble

# Here the input of the TDSCHA calculation
LANCZOS_STEPS = 300 # Number of Lanczos step
USE_THIRD_ORDER = True  # Use the third order in the calculation
USE_FOURTH_ORDER = True # Use the fourth order (2x computational cost)
SAVE_FOLDER = "cluster_"+geom # The folder in which the data are saved
SAVE_PREFIX = "tdscha_lanczos_" + geom # The name of this calculation




if FINAL_TEMPERATURE is None:
    FINAL_TEMPERATURE = TEMPERATURE

INFO = """
This file prepares the input files for the calculation on a cluster.

This script is a template.
You can easily edit the variables defining at the beginning of the script.

To run the Lanczos calculation after this script is done execute.

mpirun -np NPROC tdscha-lanczos.x {}

Inside the directory {} generated by this script, substituting NPROC with the number of processors.
The executable tdscha-lanczos.x is compiled inside the CModules directory in the root of the tdscha package.

You only need to copy the files inside the generated directory to start the lanczos. No need to copy the full ensemble.

This executable is very easy to compile on clusters, and it is the most straightforward way to perform a Lanczos calculation on a cluster.

NOTE. This scripts by default simulates a single mode specified by input.
If you want Raman or IR, uncomment the relative part of the code below.


-------------------------------------------
Input data: Check if it is what you expect

The dynamical matrix that generated the ensemble is = {}
The number of irreducible q points are = {}
Temperature of the ensemble generated = {}
The dynamical matrix at the end of the SSCHA simulation is = {}

The ensemble location is {}
The number of configurations are {}
The population id of the ensemble is {}

The number of steps in the Lanczos simulation is {}
Does the calculation include third order? {}
Does the calculation include fourth order? {}
The directory to save the status is {}
The prefix for the status name is {}

""".format(SAVE_PREFIX, SAVE_FOLDER,
           ORIGINAL_DYN, NQIRR, TEMPERATURE, FINAL_DYN,
           ENSEMBLE_DIR, N_CONFIGS, POPULATION_ID,
           LANCZOS_STEPS, USE_THIRD_ORDER, USE_FOURTH_ORDER,
           SAVE_FOLDER, SAVE_PREFIX)
           
print(INFO)

# ============== HERE THE SCRIPT ====================


# Load the dynamical matrix
dyn = CC.Phonons.Phonons(ORIGINAL_DYN, NQIRR)
final_dyn = CC.Phonons.Phonons(FINAL_DYN, NQIRR)

# Load the ensemble
print("Loading the ensemble...")
t1 = time.time()
ens = sscha.Ensemble.Ensemble(dyn, TEMPERATURE)
if LOAD_BIN:
    ens.load_bin(ENSEMBLE_DIR, POPULATION_ID)
else:
    ens.load(ENSEMBLE_DIR, POPULATION_ID, N_CONFIGS)
t2 = time.time()
print("Time to load the ensemble: {} s".format(t2-t1))


print("Updating the ensemble to the final dynamical matrix...")
ens.update_weights(final_dyn, FINAL_TEMPERATURE)


print("Prepare the Lanczos...")
lanczos = DL.Lanczos(ens)
lanczos.ignore_v3 = not USE_THIRD_ORDER
lanczos.ignore_v4 = not USE_FOURTH_ORDER
lanczos.init()



# Here the Raman perturbation (uncomment)
# NOTE: you need the Raman Tensor inside the final dynamical matrix.
## Select the incoming and outcoming light polarization
lanczos.dyn.raman_tensor = dyn.raman_tensor

v_in = conv[geom[0]]
v_out = conv[geom[1]]

v2_in = conv[geom[2]]
v2_out = conv[geom[3]]

print(v_in,v_out,v2_in,v2_out)

lanczos.prepare_raman(v_in, v_out, mixed = True, pol_vec_in2 = v2_in, pol_vec_out2 = v2_out)


# Run the calculation
print("Preparing input files...")
lanczos.prepare_input_files(n_steps = LANCZOS_STEPS,
                            directory = SAVE_FOLDER,
                            root_name = SAVE_PREFIX)
